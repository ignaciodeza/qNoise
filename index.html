<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>qNoise Interactive Explorer</title>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- jsPDF and html2canvas for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    
    <style>
        /* Apply IBM Plex Sans globally for body text */
        body {
            font-family: 'IBM Plex Sans', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f9fafb;
        }
        
        /* Container */
        .container {
            max-width: 700px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border: 1px solid #d1d5db;
        }
        
        /* Title */
        h1 {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 24pt;
            font-weight: 600;
            margin: 0 0 10px 0;
            text-align: center;
        }
        
        .subtitle {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 11pt;
            color: #6b7280;
            text-align: center;
            margin-bottom: 30px;
        }
        
        /* Publication Quality Plot Styling */
        #chart {
            background-color: white !important;
            box-shadow: none !important;
            border: 1px solid #d1d5db;
            margin-bottom: 30px;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Loading message */
        .loading {
            font-family: 'IBM Plex Sans', sans-serif;
            color: #6b7280;
            font-size: 11pt;
        }
        
        /* D3 Gridline styling */
        .grid line {
            stroke: lightgrey;
            stroke-opacity: 0.7;
            shape-rendering: crispEdges;
        }
        .grid path {
            stroke-width: 0;
        }
        
        /* Remove default black domain line for the primary axes */
        .axis .domain {
            stroke: none;
            stroke-width: 0;
        }
        
        /* Axis and tick label size */
        .axis text {
            font-size: 11pt !important;
            fill: black;
        }
        
        /* Ensure points are above grid */
        .plot-points {
            z-index: 1;
        }
        .grid-group {
            z-index: 0;
        }
        
        /* Sliders Container */
        .sliders-container {
            margin-bottom: 20px;
        }
        
        .slider-group {
            margin-bottom: 25px;
        }
        
        .slider-label {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 11pt;
            font-weight: 500;
            margin-bottom: 5px;
            display: block;
        }
        
        .slider-helper {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 9pt;
            color: #6b7280;
            margin-bottom: 10px;
        }
        
        .slider-value {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 10pt;
            color: #374151;
            float: right;
        }
        
        /* Custom slider styling */
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: black;
            cursor: pointer;
            border-radius: 50%;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: black;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        /* Slider ticks */
        .slider-ticks {
            display: flex;
            justify-content: space-between;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 8pt;
            color: #9ca3af;
            margin-top: 5px;
        }
        
        /* Toggles */
        .toggles-container {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f9fafb;
            border: 1px solid #d1d5db;
            border-radius: 3px;
        }
        
        .toggle-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .toggle-group:last-child {
            margin-bottom: 0;
        }
        
        .toggle-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            cursor: pointer;
        }
        
        .toggle-group label {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 10pt;
            color: #374151;
            cursor: pointer;
            user-select: none;
        }
        
        /* Play button */
        .play-button {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 10pt;
            padding: 10px 20px;
            background-color: white;
            color: black;
            border: 1px solid #d1d5db;
            cursor: pointer;
            width: 100%;
            margin-bottom: 10px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .play-button:hover {
            background-color: #f9fafb;
        }
        
        .play-button:active {
            background-color: #f3f4f6;
        }
        
        .play-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .play-icon {
            font-size: 12pt;
        }
        
        /* Share/permalink styling */
        .share-container {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #f9fafb;
            border: 1px solid #d1d5db;
            border-radius: 3px;
            display: none;
        }
        
        .share-container.show {
            display: block;
        }
        
        .share-url {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 8pt;
            padding: 8px;
            background-color: white;
            border: 1px solid #d1d5db;
            border-radius: 3px;
            word-break: break-all;
            margin-top: 8px;
        }
        
        .copy-button {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 9pt;
            padding: 6px 12px;
            background-color: white;
            color: black;
            border: 1px solid #d1d5db;
            cursor: pointer;
            margin-top: 8px;
            transition: background-color 0.2s;
        }
        
        .copy-button:hover {
            background-color: #f9fafb;
        }
        
        /* Tooltip */
        .tooltip-icon {
            display: inline-block;
            width: 14px;
            height: 14px;
            line-height: 14px;
            text-align: center;
            background-color: #9ca3af;
            color: white;
            border-radius: 50%;
            font-size: 10px;
            font-weight: bold;
            cursor: help;
            margin-left: 5px;
            position: relative;
        }
        
        .tooltip-icon:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 120%;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px;
            background-color: white;
            color: #374151;
            border: 1px solid #d1d5db;
            border-radius: 3px;
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 9pt;
            font-weight: normal;
            width: 250px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            line-height: 1.4;
        }
        
        .tooltip-icon:hover::before {
            content: '';
            position: absolute;
            bottom: 115%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #d1d5db;
            z-index: 1001;
        }
        
        /* Download button */
        .download-button {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 10pt;
            padding: 10px 20px;
            background-color: white;
            color: black;
            border: 1px solid #d1d5db;
            cursor: pointer;
            width: 100%;
            transition: background-color 0.2s;
        }
        
        .download-button:hover {
            background-color: #f9fafb;
        }
        
        .download-button:active {
            background-color: #f3f4f6;
        }
        
        /* Header */
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #d1d5db;
        }
        
        header h1 {
            font-size: 24pt;
            font-weight: 600;
            margin: 0 0 10px 0;
        }
        
        header h2 {
            font-size: 12pt;
            font-weight: 400;
            margin: 0 0 8px 0;
        }
        
        header h2 a {
            color: #2563eb;
            text-decoration: none;
        }
        
        header h2 a:hover {
            text-decoration: underline;
        }
        
        .author-info {
            font-size: 9pt;
            color: #6b7280;
            margin-bottom: 15px;
        }
        
        .author-info a {
            color: #2563eb;
            text-decoration: none;
        }
        
        .author-info a:hover {
            text-decoration: underline;
        }
        
        .description {
            font-size: 10pt;
            color: #374151;
            line-height: 1.6;
            max-width: 600px;
            margin: 0 auto;
        }
        
        /* Footer */
        footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #d1d5db;
            font-size: 9pt;
            color: #6b7280;
        }
        
        footer a {
            color: #2563eb;
            text-decoration: none;
            font-weight: 500;
        }
        
        footer a:hover {
            text-decoration: underline;
        }
        
        .footer-note {
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        /* Citation collapsible */
        .citation-toggle {
            background: none;
            border: none;
            color: #2563eb;
            cursor: pointer;
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 9pt;
            font-weight: 500;
            padding: 0;
            text-decoration: none;
        }
        
        .citation-toggle:hover {
            text-decoration: underline;
        }
        
        .citation-content {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background-color: #f9fafb;
            border: 1px solid #d1d5db;
            border-radius: 3px;
        }
        
        .citation-content.show {
            display: block;
        }
        
        .citation-content pre {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 8pt;
            color: #374151;
            margin: 10px 0 0 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>qNoise Interactive Explorer</h1>
            <h2>
                <a href="https://doi.org/10.1016/j.softx.2022.101034" target="_blank">
                    A Non-Gaussian and Non-White Noise Tool
                </a>
            </h2>
            <p class="author-info">
                by J. Ignacio Deza | 
                <a href="https://ignaciodeza.github.io/" target="_blank">CV</a>
            </p>
            <p class="description">
                Explore the behaviour of non-Gaussian, non-white noise interactively. Adjust parameters in real-time to understand how q-Gaussian distributions and temporal correlations shape noise characteristics.
            </p>
        </header>
        
        <div id="chart">
            <p class="loading">Loading noise parameter space...</p>
        </div>
        
        <button class="play-button" id="refresh-button" style="background-color: #f3f4f6;">
            <span>↻ Refresh Data (Generate New Realisations)</span>
        </button>
        
        <div class="sliders-container">
            <!-- q parameter slider -->
            <div class="slider-group">
                <label class="slider-label">
                    q-parameter (tail behaviour)
                    <span class="tooltip-icon" data-tooltip="The q-parameter controls the distribution shape. q < 1 produces distributions with finite support (bounded). q = 1 is exactly Gaussian. q > 1 produces heavy-tailed distributions where extreme events are more common.">i</span>
                    <span class="slider-value" id="q-value">1.0</span>
                </label>
                <div class="slider-helper">← Thin tail | Gaussian | Fat tail →</div>
                <input type="range" id="q-slider" min="0" max="5" value="1" step="1">
                <div class="slider-ticks">
                    <span>0.5</span>
                    <span>1.0</span>
                    <span>1.1</span>
                    <span>1.3</span>
                    <span>1.5</span>
                    <span>1.6</span>
                </div>
            </div>
            
            <!-- tau parameter slider -->
            <div class="slider-group">
                <label class="slider-label">
                    τ (correlation time)
                    <span class="tooltip-icon" data-tooltip="The correlation time τ controls how quickly the noise decorrelates. Small τ produces fast-changing noise, while large τ produces slowly-varying, persistent noise.">i</span>
                    <span class="slider-value" id="tau-value">1.0</span>
                </label>
                <div class="slider-helper">← Fast | Slow →</div>
                <input type="range" id="tau-slider" min="0" max="3" value="2" step="1">
                <div class="slider-ticks">
                    <span>0.01</span>
                    <span>0.1</span>
                    <span>1.0</span>
                    <span>10.0</span>
                </div>
            </div>
            
            <!-- N parameter slider -->
            <div class="slider-group">
                <label class="slider-label">
                    N (sequence length)
                    <span class="tooltip-icon" data-tooltip="The number of data points in the noise sequence. Longer sequences better reveal the statistical properties of the noise.">i</span>
                    <span class="slider-value" id="n-value">1000</span>
                </label>
                <input type="range" id="n-slider" min="0" max="3" value="2" step="1">
                <div class="slider-ticks">
                    <span>100</span>
                    <span>500</span>
                    <span>1000</span>
                    <span>5000</span>
                </div>
            </div>
        </div>
        
        <div class="toggles-container">
            <div class="toggle-group">
                <input type="checkbox" id="show-ensemble-toggle" checked>
                <label for="show-ensemble-toggle">Show ensemble members</label>
            </div>
            <div class="toggle-group">
                <input type="checkbox" id="show-statistics-toggle" checked>
                <label for="show-statistics-toggle">Show ensemble statistics (mean ± std dev)</label>
            </div>
        </div>
        
        <button class="play-button" id="play-button">
            <span class="play-icon">▶</span>
            <span>Play: Animate through q-parameter</span>
        </button>
        
        <button class="download-button" id="share-button">Share Current Configuration</button>
        <div class="share-container" id="share-container">
            <p style="margin: 0 0 5px 0; font-size: 9pt; color: #374151;">Share this link:</p>
            <div class="share-url" id="share-url"></div>
            <button class="copy-button" id="copy-button">Copy to Clipboard</button>
        </div>
        
        <button class="download-button" id="download-button">Download Current Series (CSV)</button>
        <button class="download-button" id="download-ensemble-button" style="margin-top: 10px;">Download Full Ensemble (CSV)</button>
        <button class="download-button" id="download-pdf-button" style="margin-top: 10px;">Download Figure (PDF)</button>
        
        <footer>
            <div class="footer-note">
                <a href="https://github.com/ignaciodeza/qNoise" target="_blank">Download qNoise from GitHub</a> to generate custom noise locally. Available in C++, Go, and Python (coming soon). This is a demonstration tool — for production use, please use the software directly.
            </div>
            <div>
                <button class="citation-toggle" id="citation-toggle">
                    ▸ Citation
                </button>
                <div class="citation-content" id="citation-content">
                    <p style="margin: 0 0 5px 0; font-size: 9pt; color: #374151;">If you use this software, please cite:</p>
                    <pre>@article{deza2022qnoise,
  title={qNoise: A generator of non-Gaussian colored noise},
  author={Deza, J. Ignacio and Ihshaish, Hisham},
  journal={SoftwareX},
  volume={18},
  pages={101034},
  year={2022},
  publisher={Elsevier}
}</pre>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Parameter mappings
        const qValues = [0.5, 1.0, 1.1, 1.3, 1.5, 1.6];
        const tauValues = [0.01, 0.1, 1.0, 10.0];
        const nValues = [100, 500, 1000, 5000];
        const samplingRate = 100;
        
        // Data cache for O(1) lookup
        let dataCache = {};
        
        // Current selection
        let currentQ = 1.0;
        let currentTau = 1.0;
        let currentN = 1000;
        let currentEnsemble = 0;
        let showEnsemble = true;
        let showStatistics = true;
        let isPlaying = false;
        let playInterval = null;
        
        // Fetch all data on page load
        async function loadData() {
            try {
                // First try to load from local demo_data.json.gz
                let data;
                try {
                    const response = await fetch('demo_data.json.gz');
                    if (response.ok) {
                        // Decompress gzipped data
                        const blob = await response.blob();
                        const ds = new DecompressionStream('gzip');
                        const decompressedStream = blob.stream().pipeThrough(ds);
                        const decompressedBlob = await new Response(decompressedStream).blob();
                        const text = await decompressedBlob.text();
                        data = JSON.parse(text);
                        console.log('Loaded demo data from gzipped file');
                    } else {
                        throw new Error('Demo file not found, fetching from API');
                    }
                } catch (fileError) {
                    console.log('Demo file not available, fetching from API:', fileError.message);
                    // Fall back to API call
                    const response = await fetch('https://qnoise.ew.r.appspot.com/qnoise/demo', {
                        method: 'POST',
                        headers: {
                            'Accept-Encoding': 'gzip'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    data = await response.json();
                }
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to generate noise');
                }
                
                // Build cache
                dataCache = {}; // Clear existing cache
                data.results.forEach(result => {
                    const key = `${result.q}_${result.tau}_${result.N}`;
                    if (!dataCache[key]) {
                        dataCache[key] = [];
                    }
                    dataCache[key].push(result.data);
                });
                
                console.log('Loaded', data.totalSeries, 'noise realisations');
                
                // Draw initial plot
                updatePlot();
                
                // Check URL parameters for shared configuration
                const urlHasParams = loadFromURL();
                
                // Start animation by default if no URL parameters
                if (!urlHasParams) {
                    setTimeout(() => startPlay(), 500); // Small delay to let initial plot render
                }
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('chart').innerHTML = 
                    `<p class="loading" style="color: #dc2626;">Error loading data: ${error.message}</p>`;
            }
        }
        
        // Refresh data from API
        async function refreshData() {
            const button = document.getElementById('refresh-button');
            const originalText = button.innerHTML;
            button.innerHTML = '<span>⟳ Generating new data...</span>';
            button.disabled = true;
            
            try {
                const response = await fetch('https://qnoise.ew.r.appspot.com/qnoise/demo', {
                    method: 'POST',
                    headers: {
                        'Accept-Encoding': 'gzip'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to generate noise');
                }
                
                // Build cache
                dataCache = {}; // Clear existing cache
                data.results.forEach(result => {
                    const key = `${result.q}_${result.tau}_${result.N}`;
                    if (!dataCache[key]) {
                        dataCache[key] = [];
                    }
                    dataCache[key].push(result.data);
                });
                
                console.log('Refreshed', data.totalSeries, 'noise realisations');
                
                // Redraw plot with new data
                updatePlot();
                
                button.innerHTML = '<span>✓ Data refreshed!</span>';
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.disabled = false;
                }, 2000);
                
            } catch (error) {
                console.error('Error refreshing data:', error);
                button.innerHTML = '<span>✗ Error - Try again</span>';
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.disabled = false;
                }, 2000);
            }
        }
        
        // Update plot based on current parameters
        function updatePlot(fixedYExtent = null) {
            const key = `${currentQ}_${currentTau}_${currentN}`;
            const ensembleData = dataCache[key];
            
            if (!ensembleData || ensembleData.length === 0) {
                console.error('No data found for', key);
                return;
            }
            
            const primaryData = ensembleData[currentEnsemble];
            const timeData = primaryData.map((value, index) => index / samplingRate);
            
            // Clear previous plot
            d3.select("#chart").selectAll("*").remove();
            
            // Setup dimensions
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const targetWidth = 650;
            const targetHeight = 450;
            const width = targetWidth - margin.left - margin.right;
            const height = targetHeight - margin.top - margin.bottom;
            
            const svg = d3.select("#chart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                .attr("style", "max-width: 100%; height: auto; display: block;")
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Calculate y extent - use fixed if provided, otherwise calculate
            let yMin, yMax;
            if (fixedYExtent) {
                yMin = fixedYExtent[0];
                yMax = fixedYExtent[1];
            } else {
                // Calculate global extent across all ensemble members
                let globalMin = Infinity;
                let globalMax = -Infinity;
                ensembleData.forEach(series => {
                    const extent = d3.extent(series);
                    if (extent[0] < globalMin) globalMin = extent[0];
                    if (extent[1] > globalMax) globalMax = extent[1];
                });
                yMin = globalMin;
                yMax = globalMax;
            }
            
            // Scales
            const x = d3.scaleLinear()
                .domain([0, d3.max(timeData)])
                .range([0, width]);
            
            const y = d3.scaleLinear()
                .domain([yMin, yMax]).nice()
                .range([height, 0]);
            
            // Axes
            const xAxis = d3.axisBottom(x).ticks(5).tickSize(5);
            const yAxis = d3.axisLeft(y).ticks(5).tickSize(5);
            
            // Gridlines (behind data)
            const gridGroup = svg.append("g").attr("class", "grid-group");
            
            gridGroup.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(0,${height})`)
                .call(
                    d3.axisBottom(x)
                        .ticks(5)
                        .tickSize(-height)
                        .tickFormat("")
                );
            
            gridGroup.append("g")
                .attr("class", "grid")
                .call(
                    d3.axisLeft(y)
                        .ticks(5)
                        .tickSize(-width)
                        .tickFormat("")
                );
            
            // Add axes
            svg.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(xAxis)
                .style("font-family", "'IBM Plex Mono', monospace");
            
            svg.append("g")
                .attr("class", "axis")
                .call(yAxis)
                .style("font-family", "'IBM Plex Mono', monospace");
            
            // Axis border lines
            svg.append("line")
                .attr("x1", 0).attr("x2", 0)
                .attr("y1", 0).attr("y2", height)
                .attr("stroke", "black").attr("stroke-width", 1);
            
            svg.append("line")
                .attr("x1", 0).attr("x2", width)
                .attr("y1", height).attr("y2", height)
                .attr("stroke", "black").attr("stroke-width", 1);
            
            svg.append("line")
                .attr("x1", 0).attr("x2", width)
                .attr("y1", 0).attr("y2", 0)
                .attr("stroke", "black").attr("stroke-width", 1);
            
            svg.append("line")
                .attr("x1", width).attr("x2", width)
                .attr("y1", 0).attr("y2", height)
                .attr("stroke", "black").attr("stroke-width", 1);
            
            // Determine marker size based on data length
            let markerSize;
            if (primaryData.length < 500) {
                markerSize = 2.5;
            } else if (primaryData.length < 5000) {
                markerSize = 1.0;
            } else {
                markerSize = 0.5;
            }
            
            // Draw ensemble members in grey (if enabled)
            if (showEnsemble) {
                ensembleData.forEach((series, idx) => {
                    if (idx === currentEnsemble) return; // Skip primary series
                    
                    const ensembleGroup = svg.append("g")
                        .attr("class", "ensemble-member")
                        .attr("data-ensemble-idx", idx)
                        .style("cursor", "pointer");
                    
                    // Add invisible wider hit area for easier clicking
                    ensembleGroup.selectAll("circle.hit-area")
                        .data(series)
                        .enter()
                        .append("circle")
                        .attr("class", "hit-area")
                        .attr("cx", (d, i) => x(i / samplingRate))
                        .attr("cy", d => y(d))
                        .attr("r", Math.max(markerSize * 3, 8)) // Much larger hit area
                        .attr("fill", "transparent")
                        .attr("pointer-events", "all");
                    
                    // Add visible points on top
                    ensembleGroup.selectAll("circle.visible-point")
                        .data(series)
                        .enter()
                        .append("circle")
                        .attr("class", "visible-point")
                        .attr("cx", (d, i) => x(i / samplingRate))
                        .attr("cy", d => y(d))
                        .attr("r", markerSize)
                        .attr("fill", "#6b7280")
                        .attr("opacity", 0.35)
                        .attr("pointer-events", "none"); // Don't interfere with hit area
                    
                    // Hover interaction
                    ensembleGroup
                        .on("mouseenter", function() {
                            d3.select(this).selectAll("circle.visible-point").attr("opacity", 0.6);
                        })
                        .on("mouseleave", function() {
                            d3.select(this).selectAll("circle.visible-point").attr("opacity", 0.35);
                        })
                        .on("click", function() {
                            // Stop animation when user clicks on plot
                            if (isPlaying) {
                                stopPlay();
                            }
                            currentEnsemble = idx;
                            updatePlot(fixedYExtent);
                        });
                });
            }
            
            // Draw statistics (if enabled) - with pointer-events disabled so it doesn't block clicks
            if (showStatistics) {
                // Calculate mean and std dev at each time point
                const meanData = [];
                const stdDevData = [];
                
                for (let i = 0; i < primaryData.length; i++) {
                    const values = ensembleData.map(series => series[i]);
                    const mean = d3.mean(values);
                    const stdDev = d3.deviation(values);
                    meanData.push(mean);
                    stdDevData.push(stdDev);
                }
                
                // Create area for ±1 std dev
                const area = d3.area()
                    .x((d, i) => x(i / samplingRate))
                    .y0((d, i) => y(meanData[i] - stdDevData[i]))
                    .y1((d, i) => y(meanData[i] + stdDevData[i]));
                
                svg.append("path")
                    .datum(meanData)
                    .attr("fill", "#60a5fa")
                    .attr("opacity", 0.15)
                    .attr("d", area)
                    .attr("pointer-events", "none"); // Allow clicks through the shaded area
                
                // Draw mean line
                const line = d3.line()
                    .x((d, i) => x(i / samplingRate))
                    .y(d => y(d));
                
                svg.append("path")
                    .datum(meanData)
                    .attr("fill", "none")
                    .attr("stroke", "#60a5fa")
                    .attr("stroke-width", 1.5)
                    .attr("d", line)
                    .attr("pointer-events", "none"); // Allow clicks through the line
            }
            
            // Plot primary series (on top)
            svg.append("g")
                .attr("class", "plot-points")
                .style("cursor", "pointer")
                .selectAll("circle")
                .data(primaryData)
                .enter()
                .append("circle")
                .attr("cx", (d, i) => x(timeData[i]))
                .attr("cy", d => y(d))
                .attr("r", markerSize)
                .attr("fill", "black")
                .on("click", function() {
                    // Stop animation when clicking anywhere on the plot
                    if (isPlaying) {
                        stopPlay();
                    }
                });
            
            // Axis labels
            svg.append("text")
                .attr("transform", `translate(${width / 2}, ${height + margin.bottom - 10})`)
                .style("text-anchor", "middle")
                .style("font-family", "'IBM Plex Sans', sans-serif")
                .style("font-size", "13pt")
                .attr("fill", "black")
                .text("Time (s)");
            
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height / 2))
                .attr("dy", "0.7em")
                .style("text-anchor", "middle")
                .style("font-family", "'IBM Plex Sans', sans-serif")
                .style("font-size", "13pt")
                .attr("fill", "black")
                .text("Noise Value (ξ)");
        }
        
        // Slider event listeners
        document.getElementById('q-slider').addEventListener('input', function(e) {
            const index = parseInt(e.target.value);
            currentQ = qValues[index];
            document.getElementById('q-value').textContent = currentQ.toFixed(1);
            updatePlot();
        });
        
        document.getElementById('tau-slider').addEventListener('input', function(e) {
            const index = parseInt(e.target.value);
            currentTau = tauValues[index];
            document.getElementById('tau-value').textContent = currentTau.toFixed(2);
            updatePlot();
        });
        
        document.getElementById('n-slider').addEventListener('input', function(e) {
            const index = parseInt(e.target.value);
            currentN = nValues[index];
            document.getElementById('n-value').textContent = currentN;
            updatePlot();
        });
        
        // Download button
        document.getElementById('download-button').addEventListener('click', function() {
            const key = `${currentQ}_${currentTau}_${currentN}`;
            const ensembleData = dataCache[key];
            
            if (!ensembleData || ensembleData.length === 0) {
                alert('No data available for download');
                return;
            }
            
            const dataList = ensembleData[currentEnsemble];
            const timeData = dataList.map((value, index) => index / samplingRate);
            
            const csvContent = `data:text/csv;charset=utf-8,Time (s),Value (ξ)\n` +
                dataList.map((value, index) => `${timeData[index].toFixed(5)},${value}`).join("\n");
            
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `qNoise_q${currentQ}_tau${currentTau}_N${currentN}_ensemble${currentEnsemble}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });
        
        // Download ensemble button
        document.getElementById('download-ensemble-button').addEventListener('click', function() {
            const key = `${currentQ}_${currentTau}_${currentN}`;
            const ensembleData = dataCache[key];
            
            if (!ensembleData || ensembleData.length === 0) {
                alert('No data available for download');
                return;
            }
            
            // Create CSV with all ensemble members
            let csvContent = 'data:text/csv;charset=utf-8,Time (s)';
            for (let i = 0; i < ensembleData.length; i++) {
                csvContent += `,Ensemble ${i}`;
            }
            csvContent += '\n';
            
            // Add rows
            const N = ensembleData[0].length;
            for (let i = 0; i < N; i++) {
                const time = (i / samplingRate).toFixed(5);
                let row = time;
                for (let j = 0; j < ensembleData.length; j++) {
                    row += `,${ensembleData[j][i]}`;
                }
                csvContent += row + '\n';
            }
            
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `qNoise_q${currentQ}_tau${currentTau}_N${currentN}_fullEnsemble.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });
        
        // Toggle event listeners
        document.getElementById('show-ensemble-toggle').addEventListener('change', function(e) {
            showEnsemble = e.target.checked;
            updatePlot();
        });
        
        document.getElementById('show-statistics-toggle').addEventListener('change', function(e) {
            showStatistics = e.target.checked;
            updatePlot();
        });
        
        // Download PDF button
        document.getElementById('download-pdf-button').addEventListener('click', async function() {
            const button = this;
            const originalText = button.textContent;
            button.textContent = 'Generating PDF...';
            button.disabled = true;
            
            try {
                await generatePDF();
                button.textContent = 'PDF Downloaded!';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.disabled = false;
                }, 2000);
            } catch (error) {
                console.error('Error generating PDF:', error);
                button.textContent = 'Error - Try Again';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.disabled = false;
                }, 2000);
            }
        });
        
        async function generatePDF() {
            const { jsPDF } = window.jspdf;
            
            // Generate permalink
            const params = new URLSearchParams({
                q: currentQ,
                tau: currentTau,
                n: currentN,
                ensemble: currentEnsemble,
                showEnsemble: showEnsemble,
                showStats: showStatistics
            });
            const permalink = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
            
            // Capture just the SVG element for better quality and aspect ratio
            const svgElement = document.querySelector('#chart svg');
            
            // Clone the SVG to avoid modifying the original
            const clonedSvg = svgElement.cloneNode(true);
            
            // Create a temporary container for the SVG
            const tempContainer = document.createElement('div');
            tempContainer.style.position = 'absolute';
            tempContainer.style.left = '-9999px';
            tempContainer.style.width = '1400px'; // Larger width for better quality
            tempContainer.style.height = '900px';
            tempContainer.style.backgroundColor = 'white';
            document.body.appendChild(tempContainer);
            tempContainer.appendChild(clonedSvg);
            
            // Set explicit dimensions on the cloned SVG for high quality
            clonedSvg.setAttribute('width', '1400');
            clonedSvg.setAttribute('height', '900');
            
            const canvas = await html2canvas(tempContainer, {
                scale: 2,
                backgroundColor: '#ffffff',
                width: 1400,
                height: 900
            });
            
            // Remove temporary container
            document.body.removeChild(tempContainer);
            
            const imgData = canvas.toDataURL('image/png', 1.0);
            
            // Create PDF (A4 landscape for better fit)
            const doc = new jsPDF('l', 'mm', 'a4');
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            
            // Margins
            const margin = 15;
            const usableWidth = pageWidth - (2 * margin);
            const usableHeight = pageHeight - (2 * margin);
            
            // Header - Title
            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.text('qNoise: Non-Gaussian, Non-White Noise', margin, margin);
            
            // Date in top right
            const today = new Date().toISOString().split('T')[0];
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            const dateWidth = doc.getTextWidth(today);
            doc.text(today, pageWidth - margin - dateWidth, margin);
            
            // Parameters as subtitle (below title)
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            const paramsText = `Parameters: q = ${currentQ}  |  tau = ${currentTau}  |  N = ${currentN}`;
            doc.text(paramsText, margin, margin + 6);
            
            // Calculate image dimensions to fill page (landscape orientation)
            // Image is already landscape (1400x900), so it should fit nicely
            const imgAspect = 1400 / 900; // ~1.56
            const availableHeight = usableHeight - 20; // Leave room for header and footer
            
            let imgWidth, imgHeight;
            const availableAspect = usableWidth / availableHeight;
            
            if (imgAspect > availableAspect) {
                // Image is wider - fit to width
                imgWidth = usableWidth;
                imgHeight = imgWidth / imgAspect;
            } else {
                // Image is taller - fit to height
                imgHeight = availableHeight;
                imgWidth = imgHeight * imgAspect;
            }
            
            // Center the image
            const imgX = (pageWidth - imgWidth) / 2;
            const imgY = margin + 12;
            
            doc.addImage(imgData, 'PNG', imgX, imgY, imgWidth, imgHeight);
            
            // Footer elements
            const footerY = pageHeight - 10;
            
            // Copyright (left)
            doc.setFontSize(8);
            doc.text('© J. Ignacio Deza (MIT License)', margin, footerY);
            
            // Generated by qNoise (center)
            const centerText = 'Generated by qNoise Generator';
            const centerTextWidth = doc.getTextWidth(centerText);
            const centerX = (pageWidth - centerTextWidth) / 2;
            doc.setTextColor(0, 0, 0);
            doc.text('Generated by ', centerX, footerY);
            
            // Add clickable link to "qNoise Generator"
            const linkStart = centerX + doc.getTextWidth('Generated by ');
            doc.setTextColor(37, 99, 235); // Blue color
            doc.textWithLink('qNoise Generator', linkStart, footerY, { url: 'https://github.com/ignaciodeza/qNoise' });
            doc.setTextColor(0, 0, 0); // Reset to black
            
            // QR code (right)
            const qrSize = 15;
            const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(permalink)}`;
            
            try {
                // Load QR code image
                const qrImg = await loadImage(qrUrl);
                doc.addImage(qrImg, 'PNG', pageWidth - margin - qrSize, footerY - qrSize + 3, qrSize, qrSize);
            } catch (error) {
                console.warn('Could not generate QR code:', error);
            }
            
            // Save PDF
            doc.save(`qNoise_figure_q${currentQ}_tau${currentTau}_N${currentN}.pdf`);
        }
        
        // Helper function to load image
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = url;
            });
        }
        
        // Load data on page load
        loadData();
        
        // Refresh button
        document.getElementById('refresh-button').addEventListener('click', refreshData);
        
        // Citation toggle functionality
        document.getElementById('citation-toggle').addEventListener('click', function() {
            const content = document.getElementById('citation-content');
            const toggle = document.getElementById('citation-toggle');
            
            if (content.classList.contains('show')) {
                content.classList.remove('show');
                toggle.textContent = '▸ Citation';
            } else {
                content.classList.add('show');
                toggle.textContent = '▾ Citation';
            }
        });
        
// Slider event listeners
        document.getElementById('q-slider').addEventListener('input', function(e) {
            // Stop animation when user manually moves q slider
            if (isPlaying) {
                stopPlay();
            }
            
            const index = parseInt(e.target.value);
            currentQ = qValues[index];
            document.getElementById('q-value').textContent = currentQ.toFixed(1);
            updatePlot();
        });
        
        document.getElementById('tau-slider').addEventListener('input', function(e) {
            const index = parseInt(e.target.value);
            currentTau = tauValues[index];
            document.getElementById('tau-value').textContent = currentTau.toFixed(2);
            
            // If animation was playing, restart it from current q
            if (isPlaying) {
                stopPlay();
                updatePlot();
                setTimeout(() => startPlay(), 100);
            } else {
                updatePlot();
            }
        });
        
        document.getElementById('n-slider').addEventListener('input', function(e) {
            const index = parseInt(e.target.value);
            currentN = nValues[index];
            document.getElementById('n-value').textContent = currentN;
            
            // If animation was playing, restart it from current q
            if (isPlaying) {
                stopPlay();
                updatePlot();
                setTimeout(() => startPlay(), 100);
            } else {
                updatePlot();
            }
        });
        
        // Play button functionality
        document.getElementById('play-button').addEventListener('click', function() {
            if (isPlaying) {
                stopPlay();
            } else {
                startPlay();
            }
        });
        
        function startPlay() {
            isPlaying = true;
            document.getElementById('play-button').innerHTML = '<span class="play-icon">⏸</span><span>Pause Animation</span>';
            document.getElementById('play-button').disabled = false;
            
            // Calculate fixed y-axis extent across ALL q values for current tau and N
            let globalMin = Infinity;
            let globalMax = -Infinity;
            
            qValues.forEach(q => {
                const key = `${q}_${currentTau}_${currentN}`;
                const ensembleData = dataCache[key];
                if (ensembleData) {
                    ensembleData.forEach(series => {
                        const extent = d3.extent(series);
                        if (extent[0] < globalMin) globalMin = extent[0];
                        if (extent[1] > globalMax) globalMax = extent[1];
                    });
                }
            });
            
            const fixedYExtent = [globalMin, globalMax];
            
            // Start from current q position (not always from 0.5)
            let qIndex = qValues.indexOf(currentQ);
            if (qIndex === -1) qIndex = 0; // Fallback to first value
            
            // Update plot with current q and fixed extent
            updatePlot(fixedYExtent);
            
            // Animate through q values starting from current position
            playInterval = setInterval(() => {
                qIndex++;
                if (qIndex >= qValues.length) {
                    qIndex = 0; // Loop back to start
                }
                
                currentQ = qValues[qIndex];
                document.getElementById('q-slider').value = qIndex;
                document.getElementById('q-value').textContent = currentQ.toFixed(1);
                updatePlot(fixedYExtent);
            }, 1500); // 1.5 seconds per step
        }
        
        function stopPlay() {
            isPlaying = false;
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
            document.getElementById('play-button').innerHTML = '<span class="play-icon">▶</span><span>Play: Animate through q-parameter</span>';
            
            // Return to normal plotting (dynamic y-axis)
            updatePlot();
        }
        
        // Share/Permalink functionality
        document.getElementById('share-button').addEventListener('click', function() {
            const shareContainer = document.getElementById('share-container');
            const params = new URLSearchParams({
                q: currentQ,
                tau: currentTau,
                n: currentN,
                ensemble: currentEnsemble,
                showEnsemble: showEnsemble,
                showStats: showStatistics
            });
            
            const shareUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
            document.getElementById('share-url').textContent = shareUrl;
            shareContainer.classList.add('show');
        });
        
        document.getElementById('copy-button').addEventListener('click', function() {
            const shareUrl = document.getElementById('share-url').textContent;
            navigator.clipboard.writeText(shareUrl).then(() => {
                const button = document.getElementById('copy-button');
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            });
        });
        
        function loadFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            if (params.has('q')) {
                const q = parseFloat(params.get('q'));
                const qIndex = qValues.indexOf(q);
                if (qIndex !== -1) {
                    currentQ = q;
                    document.getElementById('q-slider').value = qIndex;
                    document.getElementById('q-value').textContent = currentQ.toFixed(1);
                }
            }
            
            if (params.has('tau')) {
                const tau = parseFloat(params.get('tau'));
                const tauIndex = tauValues.indexOf(tau);
                if (tauIndex !== -1) {
                    currentTau = tau;
                    document.getElementById('tau-slider').value = tauIndex;
                    document.getElementById('tau-value').textContent = currentTau.toFixed(2);
                }
            }
            
            if (params.has('n')) {
                const n = parseInt(params.get('n'));
                const nIndex = nValues.indexOf(n);
                if (nIndex !== -1) {
                    currentN = n;
                    document.getElementById('n-slider').value = nIndex;
                    document.getElementById('n-value').textContent = currentN;
                }
            }
            
            if (params.has('ensemble')) {
                currentEnsemble = parseInt(params.get('ensemble'));
            }
            
            if (params.has('showEnsemble')) {
                showEnsemble = params.get('showEnsemble') === 'true';
                document.getElementById('show-ensemble-toggle').checked = showEnsemble;
            }
            
            if (params.has('showStats')) {
                showStatistics = params.get('showStats') === 'true';
                document.getElementById('show-statistics-toggle').checked = showStatistics;
            }
            
            // Redraw with URL parameters
            if (params.size > 0) {
                updatePlot();
                return true; // URL had parameters
            }
            return false; // No URL parameters
        }
    </script>
</body>
</html>